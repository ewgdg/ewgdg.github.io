---
templateKey: BlogPost
title: 'React Trick: How to Create an Initializer Block for a Function Component'
date: 2019-11-04T23:01:58.242Z
featuredPost: false
featuredImage: >-
  /img/react-trick-how-to-create-an-initializer-block-for-a-function-component-image1.png
tags:
  - react
  - function component
  - initialization
  - initializer block
---
This is an update on the blog in 2020:\
React useState supports lazy initial state today:
```javascript
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});

```

##
React function components come with many advantages compared to its class components and become suggested since the new release of React hooks. The React hooks allow the function components to be stateful, but it is less obvious on how to initialize states inside a function component and today I am going to solve the question.

Before diving into the details, I want to mention that there are actually two ways of persisting states in function components, `useRef` and `useState`. `useRef` is for internal states and modifying this type of states will not trigger re-rendering, while `useState` allows you to trigger re-rendering of the component. For the concern of simplicity, I will focus on `useRef` here but the idea is very similar for `useState`.

There are actually many ways to initialize the states in function components, the challenging part here is what is the most elegant way to do so. Let us start from the very basic method from React official document.

![](/img/react-trick-how-to-create-an-initializer-block-for-a-function-component-image1.png)

The official way is to directly pass initial value to `useRef`. Simple enough. However, it is not very useful if your initial state is generated by a very complex and costly computation, for example a randomly generated map data for your game. The naive way of doing this is as follows:

```js
function getInitialState(){
   // costly computation
}

const component= ()=>{
  const state = useRef(getInitialState());
  return ...
}
```

The hidden problem for this naive solution is that every time this function component is called, the initial state will be computed again, even though the component is already initialized. There will be a waste of the computation power if the component is frequently re-rendered. 

To solve this problem, we need another state to tell us whether or not this component is initialized. To make the syntax elegant and repeatable for every use case, I borrowed the concept from Java Instance Initializer block (IIB). IIB is very similar to the constructor for class. To further simplify the syntax I also create a custom hook `useInitialzationState` for recording whether or not a component is initialized. Here is how to create such a block in React function component:

```js
function useInitialzationState(){
    const isInitialized = useRef(false)
    // useEffect takes effect after component is mounted/initialized
    useEffect(() => {
        isInitialized.current = true
        return () => {
           isInitialized.current = false
        }
    }, [])
    return isInitialized.current
}
const component= ()=>{
  let initialState = null;
  const isInit =  useInitialzationState()


  /********start of the initializer block********/
  if(!isInit){ 

    // do something
    initialState = getInitialState();

  }
  /*********end of the initializer block*********/


  const state = useRef(initialState);
  return ...
}
```

The trick is that the effects passed to `useEffect` run after every completed render and hence the first time the component is rendered the `isInitialized` variable has a value of false. Since the first render, the `useEffect` will run the effects and the `isInitialized` will be true. Every other render of the component will not recalculate the initial state as a result.
